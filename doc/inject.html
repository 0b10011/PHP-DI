<!DOCTYPE html>
<html lang="en">
<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP-DI : Dependency injection with annotations in PHP</title>
    <meta name="description" content="PHP-DI is a PHP framework providing dependency injection using annotations">

    <base href="http://mnapoli.github.com/PHP-DI/">

    <!-- Le styles -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/bootstrap-responsive.min.css" rel="stylesheet">
    <link href="css/bootstrap-docs.css" rel="stylesheet">
    <link href="css/prettify.css" rel="stylesheet">
    <link href="css/template.css" rel="stylesheet">

    <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

</head>

<body>

	<header class="jumbotron subhead" id="overview">
		<div class="container">
			<h1>PHP-DI</h1>
			<p class="lead">Dependency injection with annotations in PHP.</p>
		</div>
	</header>

    <div class="container">
	
		<div class="subnav">
			<ul class="nav nav-pills">
				<li><a href="">Home</a></li>
				<li><a href="doc/getting-started">Getting started</a></li>
				<li><a href="doc/">Documentation</a></li>
                <li><a href="change-log">Change log</a></li>
			</ul>
		</div>

        <section>
<h1>Inject</h1>

<p>PHP-DI Container can contain and provide:</p>

<ul>
<li>beans (instances of classes)</li>
<li>values (configuration values, like integers, strings, arrays, ...)</li>
</ul>

<h2>The container</h2>

<p>The container is a singleton:</p>

<pre><code class="php">$container = \DI\Container::getInstance();
</code></pre>

<p>To get something from the container, you can simply do:</p>

<pre><code class="php">// Object style
$something = $container-&gt;get(&#39;something&#39;);
// Or array style
$something = $container[&#39;something&#39;];
</code></pre>

<p>(to put something into the container, read the <a href="doc/configure">configuration manual</a>)</p>

<p>If you want to get class instances, you don&#39;t need any configuration, you can simply do:</p>

<pre><code class="php">// Object style
$something = $container-&gt;get(&#39;My\GreatClass&#39;);
// Or array style
$something = $container[&#39;My\GreatClass&#39;];
</code></pre>

<p>This will simply return an instance of the class <code>My\GreatClass</code>.</p>

<h2>@Inject annotation</h2>

<p>If you are lazy (like we all are), you don&#39;t want to write that much code.
Also, if you want dependency injection, you&#39;ll have noticed by now that this looks more like
<em>Dependency Fetching</em> rather than <em>Dependency Injection</em>.</p>

<h3>Declaring</h3>

<p>We can declare a dependency to inject with the <code>@Inject</code> and <code>@var</code> annotations.</p>

<p>Like the previous example, we can inject an instance of <code>My\GreatClass</code> right into our class:</p>

<pre><code class="php">use DI\Annotations\Inject;

class MyService {
    /**
     * @Inject
     * @var My\GreatClass
     */
    private $myDependency;
}
</code></pre>

<p><em><code>@Inject</code> is annotation defined by PHP-DI, <code>@var</code> is the standard phpDocumentor annotation</em></p>

<h3>Injecting</h3>

<p>Declaring the dependency with <code>@Inject</code> is not enough: the dependency needs to be injected by PHP-DI.</p>

<p>You can&#39;t use <code>new</code> to create a new instance of your class <code>MyService</code>. Instead use PHP-DI:</p>

<pre><code class="php">// The best solution
$myService = $container-&gt;get(&#39;MyService&#39;); // The dependencies will be injected before the constructor is called

// Another solution
$myService = new MyService(); // The dependencies will not be available in the constructor
$container-&gt;injectAll($myService);

// Or also
class MyService {
    public function __construct() {
        \DI\Container::getInstance()-&gt;injectAll($this); // The dependencies are available after this line
    }
</code></pre>

<p>Where to call <code>injectAll()</code>? Several solutions are possible:</p>

<ul>
<li>in your class constructors, or in the constructor of a base class (for your controllers for example)</li>
<li>where your root application classes (front controller, routing?) are instantiated</li>
<li>or use <code>$container-&gt;get()</code> instead and you don&#39;t need to call <code>injectAll()</code></li>
<li>...</li>
</ul>

<p>For example in the <a href="getting-started">Zend Framework 1.x integration</a>, the dependencies are injected
when the controller is created by Zend Framework.</p>

<p>If your controller uses services which use repositories, then you just have to use <code>injectAll()</code>
on your controller when it is created. <strong>The dependency injection process is transitive</strong>: repositories will be injected in services which
will be injected in the controller.</p>

<h3>Value injection</h3>

<p>Like with <code>$container-&gt;get($something)</code>, you can of course inject values:</p>

<pre><code class="php">use DI\Annotations\Inject;

class MyService {
    /**
     * @Inject(&quot;db.host&quot;)
     */
    private $dbHost;
}
</code></pre>

<p>(to put something into the container, read the <a href="doc/configure">configuration manual</a>)</p>

<h3>Named injection</h3>

<p>While you can automatically inject an instance by specifying its type using the <code>@var</code> annotation,
you can also inject a <em>specific</em> instance:</p>

<pre><code class="php">$container-&gt;set(&#39;myDependency&#39;, $myObject);
</code></pre>

<p>(to put something into the container, read the <a href="doc/configure">configuration manual</a>)</p>

<p>and then:</p>

<pre><code class="php">&lt;?php
class Class1 {
    /**
     * @Inject(&quot;myDependency&quot;)
     */
    private $dependency;
</code></pre>

<h3>Lazy-loading dependencies</h3>

<p>With the default behavior, the dependencies are created when injected:</p>

<pre><code class="php">use DI\Annotations\Inject;

class Class1 {
    /**
     * @Inject
     * @var Class2
     */
    private $class2;

    public function __construct() {
        \DI\Container::getInstance()-&gt;injectAll($this);
    }

    public function getSomething() {
        return $this-&gt;class2-&gt;getSomethingElse();
    }
}
</code></pre>

<p>If you are injecting multiple dependencies and not always using them, you might not want to load and
inject all the dependencies every time the class is used.</p>

<p>You can force a dependency to be loaded only when it is used:</p>

<pre><code class="php">class Class1 {
    /**
     * @Inject(lazy=true)
     * @var Class2
     */
     private $class2;
</code></pre>

<p>In this case, when <code>Class1</code> is instantiated, a Proxy class will be injected instead of the real <code>Class2</code> dependency.</p>

<p>Only when the dependency is used (in <code>getSomething()</code>) the <code>Class2</code> instance will be loaded.</p>

<p>This can help save resources and improve performances.</p>

		</section>

    </div><!-- /container -->

    <footer class="footer">
        <div class="container">
            <p class="pull-right"><a href="#">Back to top</a></p>
            <p>
                Documentation generated by
                <a href="http://mnapoli.github.com/gh-pages-compiler/" target="_blank">gh-pages-compiler</a>.
            </p>
        </div>
    </footer>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script src="js/bootstrap.min.js"></script>
    <script src="js/prettify.js"></script>
    <script src="js/template.js"></script>

    <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-15584647-13']);
        _gaq.push(['_trackPageview']);
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>

</body>
</html>
